#!/usr/bin/env python3

import csv
import re
from pathlib import Path

import h5py
import numpy as np

idr016_location = Path('/data/images/idr/idr016')
feature_location = Path(
    '2016-02-01-features/bbbc022-Dataset_S3_image_features')

csv_image = idr016_location / feature_location / Path(
    'supplement_Per_Image.csv')

print('csv: %s' % (csv_image))

csv_objects = {}
for p in (idr016_location /
          feature_location).glob('supplement_Per_Object_[0-9]*.csv'):
    plate_id = re.search('supplement_Per_Object_(\d+).csv',
                         str(p)).group(1)
    csv_objects[plate_id] = p

for o in csv_objects.keys():
    print('  %s: %s' % (o, csv_objects[o]))

f = h5py.File("idr016.h5", "w")

ig = f.create_group("Metadata/Image")
og = f.create_group("Metadata/Objects")

with open(csv_image, newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    rows = list(reader)

    is_int = re.compile('^\d+$')
    is_float = re.compile('^\d+\.\d+$')
    float_sig_digits = re.compile('^0*\.?0*(\d+)0*\.?0*$')

    coltypes = []
    for col in range(len(reader.fieldnames)):
        print(col)

        typeinfo = {}
        colname = reader.fieldnames[col]
        typeinfo['field'] = colname
        typeinfo['column'] = col
        typeinfo['stype'] = None
        typeinfo['min'] = None
        typeinfo['max'] = None
        typeinfo['sig-digits'] = None
        coltypes.append(typeinfo)

        for row in rows:
            value = row[typeinfo['field']]
            if is_float.match(row[typeinfo['field']]):
                if typeinfo['stype'] is None:
                    typeinfo['stype'] = 'f'
            elif is_int.match(row[typeinfo['field']]):
                if typeinfo['stype'] is None or typeinfo['stype'] == 'f':
                    typeinfo['stype'] = 'i'
            else:
                typeinfo['stype'] = 's'

            if typeinfo['stype'] == 'i':
                ivalue = int(value)
            elif typeinfo['stype'] == 'f':
                ivalue = float(value)
                sigmatch = float_sig_digits.match(value)
                if sigmatch:
                    sig = len(sigmatch.group(1))
                    if sig is None:
                        sig = 0
                    if typeinfo['sig-digits'] is None:
                        typeinfo['sig-digits'] = sig
                    else:
                        typeinfo['sig-digits'] = max(
                            typeinfo['sig-digits'], sig)
            else:
                ivalue = len(value.encode('utf-8'))

            if typeinfo['min'] is None:
                typeinfo['min'] = ivalue
            else:
                typeinfo['min'] = min(typeinfo['min'], ivalue)
            if typeinfo['max'] is None:
                typeinfo['max'] = ivalue
            else:
                typeinfo['max'] = max(typeinfo['max'], ivalue)

        if typeinfo['stype'] == 'i':
            vmin = typeinfo['min']
            vmax = typeinfo['max']
            if vmin < 0:
                if vmin >= -2**7+1 and vmax <= 2**7-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'i1')
                elif vmin >= -2**15+1 and vmax <= 2**15-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'i2')
                elif vmin >= -2**31+1 and vmax <= 2**31-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'i4')
                elif vmin >= -2**63+1 and vmax <= 2**63-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'i8')
                else:
                    raise Exception("Signed integer too large: %s, %s/%s" %
                                    (typeinfo['field'], vmin, vmax))
            else:
                if vmax <= 2**8-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'u1')
                elif vmax <= 2**16-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'u2')
                elif vmax <= 2**32-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'u4')
                elif vmax <= 2**64-1:
                    typeinfo['dtype'] = (typeinfo['field'], 'u8')
                else:
                    raise Exception("Unsigned integer too large: %s, %s/%s" %
                                    (typeinfo['field'], vmin, vmax))
        elif typeinfo['stype'] == 'f':
            sig = typeinfo['sig-digits']
            if sig <= 6:
                typeinfo['dtype'] = (typeinfo['field'], 'f4')
            elif sig <= 15:
                typeinfo['dtype'] = (typeinfo['field'], 'f8')
            else:
                raise Exception("Float too large: %s, %s sig digits" %
                                (typeinfo['field'], sig))
        else:
            typeinfo['dtype'] = (typeinfo['field'], 'S' + str(typeinfo['max']))

    dtype = np.dtype([col['dtype'] for col in coltypes])

    ndata = np.empty([len(rows)], dtype=dtype)

    for row in range(len(rows)):
        items = []
        for col in range(len(reader.fieldnames)):
            field = coltypes[col]['field']
            stype = coltypes[col]['stype']
            if stype == 'i':
                items.append(int(rows[row][field]))
            elif stype == 'f':
                items.append(float(rows[row][field]))
            else:
                items.append(rows[row][field].encode('utf-8'))
        ndata[row] = tuple(items)

    id = ig.create_dataset("Data", (len(rows),), maxshape=(None,), dtype=dtype,
                           chunks=(128,), compression='gzip', data=ndata)
